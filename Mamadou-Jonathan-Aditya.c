#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, PIDControl, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Forward for Target Distance

Robot Model(s): Modified Squarebot

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 2        rightMotor          393 Motor             Right side motor, Reversed
Motor Port 3        leftMotor           393 Motor             Left side motor
I2C_1               rightIEM            Integrated Encoder    Encoder mounted on rightMotor
I2C_2               leftIEM             Integrated Encoder    Encoted mounted on leftMotor
----------------------------------------------------------------------------------------------------*/


		//directional variables for 'turnRobot' function
		const int left = 1;
		const int right = 0;

		// 1 full rotation = 12.56 inch = 1.04feet ( using 627 as target )
		const double rotation = 627;

		void forwardMovement(double target, int power)
		{
			resetMotorEncoder(rightMotor);
			resetMotorEncoder(leftMotor);

			//result holds number in feet
			double result = target * rotation;

			moveMotorTarget(rightMotor,(int)result,power,true);
			moveMotorTarget(leftMotor,(int)result,power,true);
			wait1Msec(10000);

			 while((getMotorTargetCompleted(rightMotor) == false || getMotorTargetCompleted(leftMotor) == false))
		  {
		  }

		}

		// 90 degree turn = ~ 933 as target
		void turnRobot(double target, int power, int direction)
		{
			resetMotorEncoder(rightMotor);
			resetMotorEncoder(leftMotor);

			//result holds number in feet
			double result = target * rotation;

			//left turn
			if(direction == 1)
			{
					moveMotorTarget(rightMotor,(int)result,power,true); //moveMotorTarget takes int for distance therefore the (int) casting
					moveMotorTarget(leftMotor,0,0,true);
					wait1Msec(10000);
				 while((getMotorTargetCompleted(rightMotor) == false || getMotorTargetCompleted(leftMotor) == false))
		 		 {

		 		 }
			}
			//right turn
			else
			{
						moveMotorTarget(rightMotor,0,0,true);
						moveMotorTarget(leftMotor,(int)result,power,true); //moveMotorTarget takes int for distance therefore the (int) casting
						wait1Msec(10000);
		 			  while((getMotorTargetCompleted(rightMotor) == false || getMotorTargetCompleted(leftMotor) == false))
	 				  {
	  				}
				}

		}

task main()
{

	wait1Msec(2000);

  forwardMovement(3.49, 63); //4ft straight
  turnRobot(1.68, 83, left); //2ft left turn

  forwardMovement(2.0, 63); //
  turnRobot(1.69, 83, left); //

  forwardMovement(2.75, 63);
  turnRobot(1.72, 83, right);
  forwardMovement(1.82,63);


	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);
}

#pragma config(UART_Usage, UART1, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in2,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in3,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, in4,    potentiometerSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, PIDControl, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Forward for Target Distance

Robot Model(s): Modified Squarebot

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 2        rightMotor          393 Motor             Right side motor, Reversed
Motor Port 3        leftMotor           393 Motor             Left side motor
I2C_1               rightIEM            Integrated Encoder    Encoder mounted on rightMotor
I2C_2               leftIEM             Integrated Encoder    Encoted mounted on leftMotor
----------------------------------------------------------------------------------------------------*/

	char UARTX_recv()
	{
		char rcvChar;

		rcvChar = getChar(uartOne);
		return rcvChar;
	}

	//directional variables for 'turnRobot' function
	const int left = 1;
	const int right = 0;

	//speed is the variable given for how much power and in turn speed is given to drive the robot
	int speed = 63;

	//wait time
	int waitTime = 500;
	//distance for sonar
	int distance = 9;

	//light value for line trackers
  int threshold = 1500;

	//1 full rotation = 12.56 inch = 1.04feet ( using 627 as target )
	const float rotation = 627;

	//follows line going at 1-arg power given until 2-arg distance
	//in inches is deteched by the sonar
	void forwardUntilObject(int power, int objDistance)
	{
		bool move = true;
	  while(move)
  	{
			if(SensorValue(sonarSensor) < objDistance)
			{
				motor[leftMotor]  = 0;
	      motor[rightMotor] = 0;
	      move = false;
			}
			else
			{
				motor[leftMotor]  = power;
	      motor[rightMotor] = power;
			}
		}
	}

  void raiseArm(int power)
	{
			//brief delay
			wait1Msec(2000);
			bool arm = true;
			//int result = 0;
			while (arm)
			{
				//potentiometer value to stop arm movement must be higher due to
				//power delivered to the claw, momentum/gravity, and the weight of the object
				//will cause arm to cut off at potentiometer value but drift lower for a longer time
				if(SensorValue(potentiometerSensor) == 3 || SensorValue(potentiometerSensor) > 3000)
				{
					arm = false;
					motor[armMotor] = 0;
				}
				else
				{
					motor[armMotor] = -power;
				}
			}
	}

	void openClaw()
	{
		wait1Msec(2000);
		motor[clawMotor] = 50;
		wait1Msec(1100);
	}

	void closeClaw()
	{
		wait1Msec(2000);
		motor[clawMotor] = -50;
		wait1Msec(1100);
	}

	void lowerArm(int power)
	{
			//brief delay
			wait1Msec(2000);
			bool arm = true;
			while (arm)
			{
				//potentiometer value to stop arm movement must be higher due to
				//power delivered to the claw, momentum/gravity, and the weight of the object
				//will cause arm to cut off at potentiometer value but drift lower for a longer time
				if(SensorValue(potentiometerSensor) == 1599 || SensorValue(potentiometerSensor) < 1599)
				{
					arm = false;
					motor[armMotor] = 0;
				}
				else
				{
					motor[armMotor] = 0;
					motor[armMotor] = power;
				}
			}
	}

	void forwardMovement(double target, int power)
	{
		resetMotorEncoder(rightMotor);
		resetMotorEncoder(leftMotor);

		//result holds number in feet
		double result = target * rotation;

		moveMotorTarget(rightMotor,(int)result,power,true);
		moveMotorTarget(leftMotor,(int)result,power,true);
		wait1Msec(10000);

		while((getMotorTargetCompleted(rightMotor) == false || getMotorTargetCompleted(leftMotor) == false)){}
	}

	// 90 degree turn = ~ 933 as target
	void turnRobotPivot(double target, int power, int direction)
	{
		resetMotorEncoder(rightMotor);
		resetMotorEncoder(leftMotor);

		//result holds number in feet
		double result = target * rotation;

		//left turn
		if(direction == left)
		{
			moveMotorTarget(rightMotor,(int)result,power,true); //moveMotorTarget takes int for distance therefore the (int) casting
			moveMotorTarget(leftMotor,-(int)result,-power,true);
			wait1Msec(10000);
		 	while((getMotorTargetCompleted(rightMotor) == false || getMotorTargetCompleted(leftMotor) == false)){}
		}

		//right turn
		else if(direction == right)
		{
			moveMotorTarget(rightMotor,0,-power,true);
			moveMotorTarget(leftMotor,(int)result,power,true); //moveMotorTarget takes int for distance therefore the (int) casting
			wait1Msec(10000);
			while((getMotorTargetCompleted(rightMotor) == false || getMotorTargetCompleted(leftMotor) == false)){}
		}
	}

		void turnRobot(double target, int power, int direction)
	{
		resetMotorEncoder(rightMotor);
		resetMotorEncoder(leftMotor);

		//result holds number in feet
		double result = target * rotation;

		//left turn
		if(direction == left)
		{
			moveMotorTarget(rightMotor,(int)result,power,true); //moveMotorTarget takes int for distance therefore the (int) casting
			moveMotorTarget(leftMotor,0,0,true);
			wait1Msec(10000);
		 	while((getMotorTargetCompleted(rightMotor) == false || getMotorTargetCompleted(leftMotor) == false)){}
		}

		//right turn
		else if(direction == right)
		{
			moveMotorTarget(rightMotor,0,0,true);
			moveMotorTarget(leftMotor,(int)result,power,true); //moveMotorTarget takes int for distance therefore the (int) casting
			wait1Msec(10000);
			while((getMotorTargetCompleted(rightMotor) == false || getMotorTargetCompleted(leftMotor) == false)){}
		}
	}

	void followLineUntilTime(int power)
	{
	  /* surfaces, adding them together, then dividing by 2. */
	  clearTimer(T1);
	  while(time1[T1] < 2500)
	  {
	    // RIGHT sensor sees dark:
	    if(SensorValue(lineFollowerRIGHT) > threshold)
	    {
	      // counter-steer right:
	      motor[leftMotor]  = power;
	      motor[rightMotor] = 0;
	    }
	    // CENTER sensor sees dark:
	    if(SensorValue(lineFollowerCENTER) > threshold)
	    {
	      // go straight
	      motor[leftMotor]  = power;
	      motor[rightMotor] = power;
	    }
	    // LEFT sensor sees dark:
	    if(SensorValue(lineFollowerLEFT) > threshold)
	    {
	      // counter-steer left:
	      motor[leftMotor]  = 0;
	      motor[rightMotor] = power;
	    }
	  }
	}

	void findLine()
	{
		bool move = true;
		while(move)
		{
	    if(SensorValue(lineFollowerLEFT) > threshold && SensorValue(lineFollowerCENTER) > threshold && SensorValue(lineFollowerRIGHT) > threshold)
	    {
	    	motor[leftMotor]  = 0;
	      motor[rightMotor] = 0;
	      move = false;
	    }
	    else
	    {
	    	motor[leftMotor]  = 110;
	      motor[rightMotor] = 110;
	    }
 		}
	}

	void turnLeftUntilLine()
	{
		bool move = true;
		while(move)
		{
	    if(SensorValue(lineFollowerRight) > threshold && SensorValue(lineFollowerCENTER) > threshold)
	    {
	    	move = false;
	    	motor[leftMotor]  = 0;
	      motor[rightMotor] = 0;

	    }

	    else
	    {
	      // counter-steer left:
	      motor[leftMotor]  = -60;
	      motor[rightMotor] = 60;
	    }
 		}
	}

	void turnRightUntilLine()
	{
		bool move = true;
		while(move)
		{
	    if(SensorValue(lineFollowerRIGHT) > threshold && SensorValue(lineFollowerCENTER) > threshold)
	    {
	    	move = false;
	    	motor[leftMotor]  = 0;
	      motor[rightMotor] = 0;

	    }

	    else
	    {
	      // counter-steer right:
	    	motor[rightMotor] = -60;
	      motor[leftMotor]  = 60;

	    }
 		}
	}

	//first line, turn right
	void c()
	{
		wait1Msec(100);
		findLine();
		wait1Msec(waitTime);
		turnRightUntilLine();
		wait1Msec(waitTime);
		followLineUntilTime(23);
		wait1Msec(waitTime);
		forwardUntilObject(90, distance);
		raiseArm(120);
	}

	//first line, turn left
	void b()
	{
		wait1Msec(100);
		findLine();
		wait1Msec(waitTime);
		turnLeftUntilLine();
		wait1Msec(waitTime);
		followLineUntilTime(23);
		wait1Msec(waitTime);
		forwardUntilObject(90, distance);
		raiseArm(120);
	}

		//first line, turn right
	void d()
	{
		wait1Msec(100);
		findLine();
		wait1Msec(waitTime);
		findLine();
		wait1Msec(waitTime);
		findLine();
		wait1Msec(waitTime);
		turnRightUntilLine();
		wait1Msec(waitTime);
		followLineUntilTime(23);
		wait1Msec(waitTime);
		forwardUntilObject(90, distance);
		raiseArm(120);
	}

			//third line, turn left
	void a()
	{
		wait1Msec(100);
		findLine();
		wait1Msec(waitTime);
		findLine();
		wait1Msec(waitTime);
		findLine();
		wait1Msec(waitTime);
		turnLeftUntilLine();
		wait1Msec(waitTime);
		followLineUntilTime(23);
		wait1Msec(waitTime);
		forwardUntilObject(90, distance);
		raiseArm(120);
	}

	void q()
	{
		turnRobotPivot(0.325, 63, left);
	}

	void e()
	{
		turnRobotPivot(0.325, 63, right);
	}



task main() {


			c();


	/*char cmd;
	int check = 1;

	while(check == 1)
	{
		cmd = UARTX_recv();

		if(cmd == 'a')
		{
			a();
		}
		else if(cmd == 'b')
		{
			b();
		}
		else if(cmd == 'c')
		{
			c();
		}
		else if(cmd == 'd')
		{
			d();
		}

		else if(cmd == 'q')
		{
			q();
		}

		else if(cmd == 'e')
		{
			e();
		}

		else if(cmd == 'x')
		{
			check = 0;
		}
	}*/
}
